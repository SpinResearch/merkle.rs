var searchIndex = {};
searchIndex["merkle"] = {"doc":"*merkle* implements a Merkle Tree in Rust.","items":[[3,"MerkleTree","merkle","A Merkle tree is a binary tree, with values of type `T` at the leafs,\nand where every internal node holds the hash of the concatenation of the hashes of its children nodes.",null,null],[12,"algorithm","","The hashing algorithm used by this Merkle tree",0,null],[3,"Proof","","An inclusion proof represent the fact that a `value` is a member\nof a `MerkleTree` with root hash `root_hash`, and hash function `algorithm`.",null,null],[12,"algorithm","","The hashing algorithm used in the original `MerkleTree`",1,null],[12,"root_hash","","The hash of the root of the original `MerkleTree`",1,null],[12,"lemma","","The first `Lemma` of the `Proof`",1,null],[12,"value","","The value concerned by this `Proof`",1,null],[3,"LeavesIterator","","An borrowing iterator over the leaves of a `Tree`.\nAdapted from http://codereview.stackexchange.com/q/110283.",null,null],[3,"LeavesIntoIterator","","An iterator over the leaves of a `Tree`.",null,null],[11,"clone","","",0,null],[11,"fmt","","",0,null],[11,"from_vec","","Constructs a Merkle Tree from a vector of data blocks.\nReturns `None` if `values` is empty.",0,{"inputs":[{"name":"algorithm"},{"name":"vec"}],"output":{"name":"self"}}],[11,"root_hash","","Returns the root hash of Merkle tree",0,null],[11,"height","","Returns the height of Merkle tree",0,null],[11,"count","","Returns the number of leaves in the Merkle tree",0,null],[11,"is_empty","","Returns whether the Merkle tree is empty or not",0,null],[11,"gen_proof","","Generate an inclusion proof for the given value.\nReturns `None` if the given value is not found in the tree.",0,null],[11,"iter","","Creates an `Iterator` over the values contained in this Merkle tree.",0,null],[11,"into_iter","","Creates a consuming iterator, that is, one that moves each value out of the Merkle tree.\nThe tree cannot be used after calling this.",0,null],[11,"clone","","",1,null],[11,"fmt","","",1,null],[11,"new","","Constructs a new `Proof`",1,{"inputs":[{"name":"algorithm"},{"name":"vec"},{"name":"lemma"},{"name":"t"}],"output":{"name":"self"}}],[11,"validate","","Checks whether this inclusion proof is well-formed,\nand whether its root hash matches the given `root_hash`.",1,null],[11,"next","","",2,null],[11,"next","","",3,null],[8,"Hashable","","The type of values stored in a `MerkleTree` must implement\nthis trait, in order for them to be able to be fed\nto a Ring `Context` when computing the hash of a leaf.",null,null],[10,"update_context","","Update the given `context` with `self`.",4,null]],"paths":[[3,"MerkleTree"],[3,"Proof"],[3,"LeavesIterator"],[3,"LeavesIntoIterator"],[8,"Hashable"]]};
initSearch(searchIndex);
