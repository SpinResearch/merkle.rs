var searchIndex = {};
searchIndex["merkle"] = {"doc":"*merkle* implements a Merkle Tree in Rust.","items":[[3,"MerkleTree","merkle","A Merkle tree is a binary tree, with values of type `T` at the leafs,\nand where every node holds the hash of the concatenation of the hashes of\nits children nodes.",null,null],[3,"Proof","","An inclusion proof represent the fact that a `value` is a member\nof a `MerkleTree` with root hash `root_hash`, and hash function `digest`.",null,null],[11,"from_vec_unsafe","","Constructs a Merkle Tree from a vector of data blocks.\nWARNING: Panics if `values` is empty!",0,{"inputs":[{"name":"d"},{"name":"vec"}],"output":{"name":"self"}}],[11,"from_vec","","Constructs a Merkle Tree from a vector of data blocks.\nReturns None if `values` is empty.",0,{"inputs":[{"name":"d"},{"name":"vec"}],"output":{"name":"option"}}],[11,"digest","","Returns the hash function used in this Merkle tree",0,null],[11,"root_hash","","Returns the root hash of Merkle tree",0,null],[11,"height","","Returns the height of Merkle tree",0,null],[11,"count","","Returns the number of leaves in the Merkle tree",0,null],[11,"gen_proof","","Generate an inclusion proof for the given value.\nReturns `None` if the given value is not found in the tree.",0,null],[11,"new","","Constructs a new `Proof`",1,{"inputs":[{"name":"d"},{"name":"vec"},{"name":"lemma"}],"output":{"name":"self"}}],[11,"validate","","Checks whether this inclusion proof is well-formed,\nand whether its root hash matches the given `root_hash`.",1,null]],"paths":[[3,"MerkleTree"],[3,"Proof"]]};
initSearch(searchIndex);
